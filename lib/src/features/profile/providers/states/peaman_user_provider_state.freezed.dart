// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'peaman_user_provider_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PeamanUserProviderState {
  UpdateUserState get updateUserState => throw _privateConstructorUsedError;
  BlockUserState get blockUserState => throw _privateConstructorUsedError;
  UnblockUserState get unblockUserState => throw _privateConstructorUsedError;
  FollowUserState get followUserState => throw _privateConstructorUsedError;
  UnfollowUserState get unfollowUserState => throw _privateConstructorUsedError;
  CancelFollowState get cancelFollowState => throw _privateConstructorUsedError;
  AcceptFollowState get acceptFollowState => throw _privateConstructorUsedError;
  FollowBackState get followBackState => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PeamanUserProviderStateCopyWith<PeamanUserProviderState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PeamanUserProviderStateCopyWith<$Res> {
  factory $PeamanUserProviderStateCopyWith(PeamanUserProviderState value,
          $Res Function(PeamanUserProviderState) then) =
      _$PeamanUserProviderStateCopyWithImpl<$Res, PeamanUserProviderState>;
  @useResult
  $Res call(
      {UpdateUserState updateUserState,
      BlockUserState blockUserState,
      UnblockUserState unblockUserState,
      FollowUserState followUserState,
      UnfollowUserState unfollowUserState,
      CancelFollowState cancelFollowState,
      AcceptFollowState acceptFollowState,
      FollowBackState followBackState});

  $UpdateUserStateCopyWith<$Res> get updateUserState;
  $BlockUserStateCopyWith<$Res> get blockUserState;
  $UnblockUserStateCopyWith<$Res> get unblockUserState;
  $FollowUserStateCopyWith<$Res> get followUserState;
  $UnfollowUserStateCopyWith<$Res> get unfollowUserState;
  $CancelFollowStateCopyWith<$Res> get cancelFollowState;
  $AcceptFollowStateCopyWith<$Res> get acceptFollowState;
  $FollowBackStateCopyWith<$Res> get followBackState;
}

/// @nodoc
class _$PeamanUserProviderStateCopyWithImpl<$Res,
        $Val extends PeamanUserProviderState>
    implements $PeamanUserProviderStateCopyWith<$Res> {
  _$PeamanUserProviderStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? updateUserState = null,
    Object? blockUserState = null,
    Object? unblockUserState = null,
    Object? followUserState = null,
    Object? unfollowUserState = null,
    Object? cancelFollowState = null,
    Object? acceptFollowState = null,
    Object? followBackState = null,
  }) {
    return _then(_value.copyWith(
      updateUserState: null == updateUserState
          ? _value.updateUserState
          : updateUserState // ignore: cast_nullable_to_non_nullable
              as UpdateUserState,
      blockUserState: null == blockUserState
          ? _value.blockUserState
          : blockUserState // ignore: cast_nullable_to_non_nullable
              as BlockUserState,
      unblockUserState: null == unblockUserState
          ? _value.unblockUserState
          : unblockUserState // ignore: cast_nullable_to_non_nullable
              as UnblockUserState,
      followUserState: null == followUserState
          ? _value.followUserState
          : followUserState // ignore: cast_nullable_to_non_nullable
              as FollowUserState,
      unfollowUserState: null == unfollowUserState
          ? _value.unfollowUserState
          : unfollowUserState // ignore: cast_nullable_to_non_nullable
              as UnfollowUserState,
      cancelFollowState: null == cancelFollowState
          ? _value.cancelFollowState
          : cancelFollowState // ignore: cast_nullable_to_non_nullable
              as CancelFollowState,
      acceptFollowState: null == acceptFollowState
          ? _value.acceptFollowState
          : acceptFollowState // ignore: cast_nullable_to_non_nullable
              as AcceptFollowState,
      followBackState: null == followBackState
          ? _value.followBackState
          : followBackState // ignore: cast_nullable_to_non_nullable
              as FollowBackState,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UpdateUserStateCopyWith<$Res> get updateUserState {
    return $UpdateUserStateCopyWith<$Res>(_value.updateUserState, (value) {
      return _then(_value.copyWith(updateUserState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $BlockUserStateCopyWith<$Res> get blockUserState {
    return $BlockUserStateCopyWith<$Res>(_value.blockUserState, (value) {
      return _then(_value.copyWith(blockUserState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UnblockUserStateCopyWith<$Res> get unblockUserState {
    return $UnblockUserStateCopyWith<$Res>(_value.unblockUserState, (value) {
      return _then(_value.copyWith(unblockUserState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FollowUserStateCopyWith<$Res> get followUserState {
    return $FollowUserStateCopyWith<$Res>(_value.followUserState, (value) {
      return _then(_value.copyWith(followUserState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UnfollowUserStateCopyWith<$Res> get unfollowUserState {
    return $UnfollowUserStateCopyWith<$Res>(_value.unfollowUserState, (value) {
      return _then(_value.copyWith(unfollowUserState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CancelFollowStateCopyWith<$Res> get cancelFollowState {
    return $CancelFollowStateCopyWith<$Res>(_value.cancelFollowState, (value) {
      return _then(_value.copyWith(cancelFollowState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AcceptFollowStateCopyWith<$Res> get acceptFollowState {
    return $AcceptFollowStateCopyWith<$Res>(_value.acceptFollowState, (value) {
      return _then(_value.copyWith(acceptFollowState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FollowBackStateCopyWith<$Res> get followBackState {
    return $FollowBackStateCopyWith<$Res>(_value.followBackState, (value) {
      return _then(_value.copyWith(followBackState: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PeamanUserProviderStateCopyWith<$Res>
    implements $PeamanUserProviderStateCopyWith<$Res> {
  factory _$$_PeamanUserProviderStateCopyWith(_$_PeamanUserProviderState value,
          $Res Function(_$_PeamanUserProviderState) then) =
      __$$_PeamanUserProviderStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {UpdateUserState updateUserState,
      BlockUserState blockUserState,
      UnblockUserState unblockUserState,
      FollowUserState followUserState,
      UnfollowUserState unfollowUserState,
      CancelFollowState cancelFollowState,
      AcceptFollowState acceptFollowState,
      FollowBackState followBackState});

  @override
  $UpdateUserStateCopyWith<$Res> get updateUserState;
  @override
  $BlockUserStateCopyWith<$Res> get blockUserState;
  @override
  $UnblockUserStateCopyWith<$Res> get unblockUserState;
  @override
  $FollowUserStateCopyWith<$Res> get followUserState;
  @override
  $UnfollowUserStateCopyWith<$Res> get unfollowUserState;
  @override
  $CancelFollowStateCopyWith<$Res> get cancelFollowState;
  @override
  $AcceptFollowStateCopyWith<$Res> get acceptFollowState;
  @override
  $FollowBackStateCopyWith<$Res> get followBackState;
}

/// @nodoc
class __$$_PeamanUserProviderStateCopyWithImpl<$Res>
    extends _$PeamanUserProviderStateCopyWithImpl<$Res,
        _$_PeamanUserProviderState>
    implements _$$_PeamanUserProviderStateCopyWith<$Res> {
  __$$_PeamanUserProviderStateCopyWithImpl(_$_PeamanUserProviderState _value,
      $Res Function(_$_PeamanUserProviderState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? updateUserState = null,
    Object? blockUserState = null,
    Object? unblockUserState = null,
    Object? followUserState = null,
    Object? unfollowUserState = null,
    Object? cancelFollowState = null,
    Object? acceptFollowState = null,
    Object? followBackState = null,
  }) {
    return _then(_$_PeamanUserProviderState(
      updateUserState: null == updateUserState
          ? _value.updateUserState
          : updateUserState // ignore: cast_nullable_to_non_nullable
              as UpdateUserState,
      blockUserState: null == blockUserState
          ? _value.blockUserState
          : blockUserState // ignore: cast_nullable_to_non_nullable
              as BlockUserState,
      unblockUserState: null == unblockUserState
          ? _value.unblockUserState
          : unblockUserState // ignore: cast_nullable_to_non_nullable
              as UnblockUserState,
      followUserState: null == followUserState
          ? _value.followUserState
          : followUserState // ignore: cast_nullable_to_non_nullable
              as FollowUserState,
      unfollowUserState: null == unfollowUserState
          ? _value.unfollowUserState
          : unfollowUserState // ignore: cast_nullable_to_non_nullable
              as UnfollowUserState,
      cancelFollowState: null == cancelFollowState
          ? _value.cancelFollowState
          : cancelFollowState // ignore: cast_nullable_to_non_nullable
              as CancelFollowState,
      acceptFollowState: null == acceptFollowState
          ? _value.acceptFollowState
          : acceptFollowState // ignore: cast_nullable_to_non_nullable
              as AcceptFollowState,
      followBackState: null == followBackState
          ? _value.followBackState
          : followBackState // ignore: cast_nullable_to_non_nullable
              as FollowBackState,
    ));
  }
}

/// @nodoc

class _$_PeamanUserProviderState implements _PeamanUserProviderState {
  const _$_PeamanUserProviderState(
      {this.updateUserState = const UpdateUserState.initial(),
      this.blockUserState = const BlockUserState.initial(),
      this.unblockUserState = const UnblockUserState.initial(),
      this.followUserState = const FollowUserState.initial(),
      this.unfollowUserState = const UnfollowUserState.initial(),
      this.cancelFollowState = const CancelFollowState.initial(),
      this.acceptFollowState = const AcceptFollowState.initial(),
      this.followBackState = const FollowBackState.initial()});

  @override
  @JsonKey()
  final UpdateUserState updateUserState;
  @override
  @JsonKey()
  final BlockUserState blockUserState;
  @override
  @JsonKey()
  final UnblockUserState unblockUserState;
  @override
  @JsonKey()
  final FollowUserState followUserState;
  @override
  @JsonKey()
  final UnfollowUserState unfollowUserState;
  @override
  @JsonKey()
  final CancelFollowState cancelFollowState;
  @override
  @JsonKey()
  final AcceptFollowState acceptFollowState;
  @override
  @JsonKey()
  final FollowBackState followBackState;

  @override
  String toString() {
    return 'PeamanUserProviderState(updateUserState: $updateUserState, blockUserState: $blockUserState, unblockUserState: $unblockUserState, followUserState: $followUserState, unfollowUserState: $unfollowUserState, cancelFollowState: $cancelFollowState, acceptFollowState: $acceptFollowState, followBackState: $followBackState)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PeamanUserProviderState &&
            (identical(other.updateUserState, updateUserState) ||
                other.updateUserState == updateUserState) &&
            (identical(other.blockUserState, blockUserState) ||
                other.blockUserState == blockUserState) &&
            (identical(other.unblockUserState, unblockUserState) ||
                other.unblockUserState == unblockUserState) &&
            (identical(other.followUserState, followUserState) ||
                other.followUserState == followUserState) &&
            (identical(other.unfollowUserState, unfollowUserState) ||
                other.unfollowUserState == unfollowUserState) &&
            (identical(other.cancelFollowState, cancelFollowState) ||
                other.cancelFollowState == cancelFollowState) &&
            (identical(other.acceptFollowState, acceptFollowState) ||
                other.acceptFollowState == acceptFollowState) &&
            (identical(other.followBackState, followBackState) ||
                other.followBackState == followBackState));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      updateUserState,
      blockUserState,
      unblockUserState,
      followUserState,
      unfollowUserState,
      cancelFollowState,
      acceptFollowState,
      followBackState);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PeamanUserProviderStateCopyWith<_$_PeamanUserProviderState>
      get copyWith =>
          __$$_PeamanUserProviderStateCopyWithImpl<_$_PeamanUserProviderState>(
              this, _$identity);
}

abstract class _PeamanUserProviderState implements PeamanUserProviderState {
  const factory _PeamanUserProviderState(
      {final UpdateUserState updateUserState,
      final BlockUserState blockUserState,
      final UnblockUserState unblockUserState,
      final FollowUserState followUserState,
      final UnfollowUserState unfollowUserState,
      final CancelFollowState cancelFollowState,
      final AcceptFollowState acceptFollowState,
      final FollowBackState followBackState}) = _$_PeamanUserProviderState;

  @override
  UpdateUserState get updateUserState;
  @override
  BlockUserState get blockUserState;
  @override
  UnblockUserState get unblockUserState;
  @override
  FollowUserState get followUserState;
  @override
  UnfollowUserState get unfollowUserState;
  @override
  CancelFollowState get cancelFollowState;
  @override
  AcceptFollowState get acceptFollowState;
  @override
  FollowBackState get followBackState;
  @override
  @JsonKey(ignore: true)
  _$$_PeamanUserProviderStateCopyWith<_$_PeamanUserProviderState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BlockUserState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BlockUserStateInitial value) initial,
    required TResult Function(_BlockUserStateLoading value) loading,
    required TResult Function(_BlockUserStateSuccess value) success,
    required TResult Function(_BlockUserStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_BlockUserStateInitial value)? initial,
    TResult? Function(_BlockUserStateLoading value)? loading,
    TResult? Function(_BlockUserStateSuccess value)? success,
    TResult? Function(_BlockUserStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BlockUserStateInitial value)? initial,
    TResult Function(_BlockUserStateLoading value)? loading,
    TResult Function(_BlockUserStateSuccess value)? success,
    TResult Function(_BlockUserStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlockUserStateCopyWith<$Res> {
  factory $BlockUserStateCopyWith(
          BlockUserState value, $Res Function(BlockUserState) then) =
      _$BlockUserStateCopyWithImpl<$Res, BlockUserState>;
}

/// @nodoc
class _$BlockUserStateCopyWithImpl<$Res, $Val extends BlockUserState>
    implements $BlockUserStateCopyWith<$Res> {
  _$BlockUserStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_BlockUserStateInitialCopyWith<$Res> {
  factory _$$_BlockUserStateInitialCopyWith(_$_BlockUserStateInitial value,
          $Res Function(_$_BlockUserStateInitial) then) =
      __$$_BlockUserStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_BlockUserStateInitialCopyWithImpl<$Res>
    extends _$BlockUserStateCopyWithImpl<$Res, _$_BlockUserStateInitial>
    implements _$$_BlockUserStateInitialCopyWith<$Res> {
  __$$_BlockUserStateInitialCopyWithImpl(_$_BlockUserStateInitial _value,
      $Res Function(_$_BlockUserStateInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_BlockUserStateInitial implements _BlockUserStateInitial {
  const _$_BlockUserStateInitial();

  @override
  String toString() {
    return 'BlockUserState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_BlockUserStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BlockUserStateInitial value) initial,
    required TResult Function(_BlockUserStateLoading value) loading,
    required TResult Function(_BlockUserStateSuccess value) success,
    required TResult Function(_BlockUserStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_BlockUserStateInitial value)? initial,
    TResult? Function(_BlockUserStateLoading value)? loading,
    TResult? Function(_BlockUserStateSuccess value)? success,
    TResult? Function(_BlockUserStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BlockUserStateInitial value)? initial,
    TResult Function(_BlockUserStateLoading value)? loading,
    TResult Function(_BlockUserStateSuccess value)? success,
    TResult Function(_BlockUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _BlockUserStateInitial implements BlockUserState {
  const factory _BlockUserStateInitial() = _$_BlockUserStateInitial;
}

/// @nodoc
abstract class _$$_BlockUserStateLoadingCopyWith<$Res> {
  factory _$$_BlockUserStateLoadingCopyWith(_$_BlockUserStateLoading value,
          $Res Function(_$_BlockUserStateLoading) then) =
      __$$_BlockUserStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_BlockUserStateLoadingCopyWithImpl<$Res>
    extends _$BlockUserStateCopyWithImpl<$Res, _$_BlockUserStateLoading>
    implements _$$_BlockUserStateLoadingCopyWith<$Res> {
  __$$_BlockUserStateLoadingCopyWithImpl(_$_BlockUserStateLoading _value,
      $Res Function(_$_BlockUserStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_BlockUserStateLoading implements _BlockUserStateLoading {
  const _$_BlockUserStateLoading();

  @override
  String toString() {
    return 'BlockUserState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_BlockUserStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BlockUserStateInitial value) initial,
    required TResult Function(_BlockUserStateLoading value) loading,
    required TResult Function(_BlockUserStateSuccess value) success,
    required TResult Function(_BlockUserStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_BlockUserStateInitial value)? initial,
    TResult? Function(_BlockUserStateLoading value)? loading,
    TResult? Function(_BlockUserStateSuccess value)? success,
    TResult? Function(_BlockUserStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BlockUserStateInitial value)? initial,
    TResult Function(_BlockUserStateLoading value)? loading,
    TResult Function(_BlockUserStateSuccess value)? success,
    TResult Function(_BlockUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _BlockUserStateLoading implements BlockUserState {
  const factory _BlockUserStateLoading() = _$_BlockUserStateLoading;
}

/// @nodoc
abstract class _$$_BlockUserStateSuccessCopyWith<$Res> {
  factory _$$_BlockUserStateSuccessCopyWith(_$_BlockUserStateSuccess value,
          $Res Function(_$_BlockUserStateSuccess) then) =
      __$$_BlockUserStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({bool result});
}

/// @nodoc
class __$$_BlockUserStateSuccessCopyWithImpl<$Res>
    extends _$BlockUserStateCopyWithImpl<$Res, _$_BlockUserStateSuccess>
    implements _$$_BlockUserStateSuccessCopyWith<$Res> {
  __$$_BlockUserStateSuccessCopyWithImpl(_$_BlockUserStateSuccess _value,
      $Res Function(_$_BlockUserStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$_BlockUserStateSuccess(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_BlockUserStateSuccess implements _BlockUserStateSuccess {
  const _$_BlockUserStateSuccess(this.result);

  @override
  final bool result;

  @override
  String toString() {
    return 'BlockUserState.success(result: $result)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BlockUserStateSuccess &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BlockUserStateSuccessCopyWith<_$_BlockUserStateSuccess> get copyWith =>
      __$$_BlockUserStateSuccessCopyWithImpl<_$_BlockUserStateSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BlockUserStateInitial value) initial,
    required TResult Function(_BlockUserStateLoading value) loading,
    required TResult Function(_BlockUserStateSuccess value) success,
    required TResult Function(_BlockUserStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_BlockUserStateInitial value)? initial,
    TResult? Function(_BlockUserStateLoading value)? loading,
    TResult? Function(_BlockUserStateSuccess value)? success,
    TResult? Function(_BlockUserStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BlockUserStateInitial value)? initial,
    TResult Function(_BlockUserStateLoading value)? loading,
    TResult Function(_BlockUserStateSuccess value)? success,
    TResult Function(_BlockUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _BlockUserStateSuccess implements BlockUserState {
  const factory _BlockUserStateSuccess(final bool result) =
      _$_BlockUserStateSuccess;

  bool get result;
  @JsonKey(ignore: true)
  _$$_BlockUserStateSuccessCopyWith<_$_BlockUserStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_BlockUserStateErrorCopyWith<$Res> {
  factory _$$_BlockUserStateErrorCopyWith(_$_BlockUserStateError value,
          $Res Function(_$_BlockUserStateError) then) =
      __$$_BlockUserStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$_BlockUserStateErrorCopyWithImpl<$Res>
    extends _$BlockUserStateCopyWithImpl<$Res, _$_BlockUserStateError>
    implements _$$_BlockUserStateErrorCopyWith<$Res> {
  __$$_BlockUserStateErrorCopyWithImpl(_$_BlockUserStateError _value,
      $Res Function(_$_BlockUserStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_BlockUserStateError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$_BlockUserStateError implements _BlockUserStateError {
  const _$_BlockUserStateError(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'BlockUserState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BlockUserStateError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BlockUserStateErrorCopyWith<_$_BlockUserStateError> get copyWith =>
      __$$_BlockUserStateErrorCopyWithImpl<_$_BlockUserStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BlockUserStateInitial value) initial,
    required TResult Function(_BlockUserStateLoading value) loading,
    required TResult Function(_BlockUserStateSuccess value) success,
    required TResult Function(_BlockUserStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_BlockUserStateInitial value)? initial,
    TResult? Function(_BlockUserStateLoading value)? loading,
    TResult? Function(_BlockUserStateSuccess value)? success,
    TResult? Function(_BlockUserStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BlockUserStateInitial value)? initial,
    TResult Function(_BlockUserStateLoading value)? loading,
    TResult Function(_BlockUserStateSuccess value)? success,
    TResult Function(_BlockUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _BlockUserStateError implements BlockUserState {
  const factory _BlockUserStateError(final PeamanError error) =
      _$_BlockUserStateError;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$_BlockUserStateErrorCopyWith<_$_BlockUserStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UnblockUserState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnblockUserStateInitial value) initial,
    required TResult Function(_UnblockUserStateLoading value) loading,
    required TResult Function(_UnblockUserStateSuccess value) success,
    required TResult Function(_UnblockUserStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnblockUserStateInitial value)? initial,
    TResult? Function(_UnblockUserStateLoading value)? loading,
    TResult? Function(_UnblockUserStateSuccess value)? success,
    TResult? Function(_UnblockUserStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnblockUserStateInitial value)? initial,
    TResult Function(_UnblockUserStateLoading value)? loading,
    TResult Function(_UnblockUserStateSuccess value)? success,
    TResult Function(_UnblockUserStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnblockUserStateCopyWith<$Res> {
  factory $UnblockUserStateCopyWith(
          UnblockUserState value, $Res Function(UnblockUserState) then) =
      _$UnblockUserStateCopyWithImpl<$Res, UnblockUserState>;
}

/// @nodoc
class _$UnblockUserStateCopyWithImpl<$Res, $Val extends UnblockUserState>
    implements $UnblockUserStateCopyWith<$Res> {
  _$UnblockUserStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UnblockUserStateInitialCopyWith<$Res> {
  factory _$$_UnblockUserStateInitialCopyWith(_$_UnblockUserStateInitial value,
          $Res Function(_$_UnblockUserStateInitial) then) =
      __$$_UnblockUserStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnblockUserStateInitialCopyWithImpl<$Res>
    extends _$UnblockUserStateCopyWithImpl<$Res, _$_UnblockUserStateInitial>
    implements _$$_UnblockUserStateInitialCopyWith<$Res> {
  __$$_UnblockUserStateInitialCopyWithImpl(_$_UnblockUserStateInitial _value,
      $Res Function(_$_UnblockUserStateInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnblockUserStateInitial implements _UnblockUserStateInitial {
  const _$_UnblockUserStateInitial();

  @override
  String toString() {
    return 'UnblockUserState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnblockUserStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnblockUserStateInitial value) initial,
    required TResult Function(_UnblockUserStateLoading value) loading,
    required TResult Function(_UnblockUserStateSuccess value) success,
    required TResult Function(_UnblockUserStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnblockUserStateInitial value)? initial,
    TResult? Function(_UnblockUserStateLoading value)? loading,
    TResult? Function(_UnblockUserStateSuccess value)? success,
    TResult? Function(_UnblockUserStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnblockUserStateInitial value)? initial,
    TResult Function(_UnblockUserStateLoading value)? loading,
    TResult Function(_UnblockUserStateSuccess value)? success,
    TResult Function(_UnblockUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _UnblockUserStateInitial implements UnblockUserState {
  const factory _UnblockUserStateInitial() = _$_UnblockUserStateInitial;
}

/// @nodoc
abstract class _$$_UnblockUserStateLoadingCopyWith<$Res> {
  factory _$$_UnblockUserStateLoadingCopyWith(_$_UnblockUserStateLoading value,
          $Res Function(_$_UnblockUserStateLoading) then) =
      __$$_UnblockUserStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnblockUserStateLoadingCopyWithImpl<$Res>
    extends _$UnblockUserStateCopyWithImpl<$Res, _$_UnblockUserStateLoading>
    implements _$$_UnblockUserStateLoadingCopyWith<$Res> {
  __$$_UnblockUserStateLoadingCopyWithImpl(_$_UnblockUserStateLoading _value,
      $Res Function(_$_UnblockUserStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnblockUserStateLoading implements _UnblockUserStateLoading {
  const _$_UnblockUserStateLoading();

  @override
  String toString() {
    return 'UnblockUserState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnblockUserStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnblockUserStateInitial value) initial,
    required TResult Function(_UnblockUserStateLoading value) loading,
    required TResult Function(_UnblockUserStateSuccess value) success,
    required TResult Function(_UnblockUserStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnblockUserStateInitial value)? initial,
    TResult? Function(_UnblockUserStateLoading value)? loading,
    TResult? Function(_UnblockUserStateSuccess value)? success,
    TResult? Function(_UnblockUserStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnblockUserStateInitial value)? initial,
    TResult Function(_UnblockUserStateLoading value)? loading,
    TResult Function(_UnblockUserStateSuccess value)? success,
    TResult Function(_UnblockUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _UnblockUserStateLoading implements UnblockUserState {
  const factory _UnblockUserStateLoading() = _$_UnblockUserStateLoading;
}

/// @nodoc
abstract class _$$_UnblockUserStateSuccessCopyWith<$Res> {
  factory _$$_UnblockUserStateSuccessCopyWith(_$_UnblockUserStateSuccess value,
          $Res Function(_$_UnblockUserStateSuccess) then) =
      __$$_UnblockUserStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({bool result});
}

/// @nodoc
class __$$_UnblockUserStateSuccessCopyWithImpl<$Res>
    extends _$UnblockUserStateCopyWithImpl<$Res, _$_UnblockUserStateSuccess>
    implements _$$_UnblockUserStateSuccessCopyWith<$Res> {
  __$$_UnblockUserStateSuccessCopyWithImpl(_$_UnblockUserStateSuccess _value,
      $Res Function(_$_UnblockUserStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$_UnblockUserStateSuccess(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_UnblockUserStateSuccess implements _UnblockUserStateSuccess {
  const _$_UnblockUserStateSuccess(this.result);

  @override
  final bool result;

  @override
  String toString() {
    return 'UnblockUserState.success(result: $result)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnblockUserStateSuccess &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UnblockUserStateSuccessCopyWith<_$_UnblockUserStateSuccess>
      get copyWith =>
          __$$_UnblockUserStateSuccessCopyWithImpl<_$_UnblockUserStateSuccess>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnblockUserStateInitial value) initial,
    required TResult Function(_UnblockUserStateLoading value) loading,
    required TResult Function(_UnblockUserStateSuccess value) success,
    required TResult Function(_UnblockUserStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnblockUserStateInitial value)? initial,
    TResult? Function(_UnblockUserStateLoading value)? loading,
    TResult? Function(_UnblockUserStateSuccess value)? success,
    TResult? Function(_UnblockUserStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnblockUserStateInitial value)? initial,
    TResult Function(_UnblockUserStateLoading value)? loading,
    TResult Function(_UnblockUserStateSuccess value)? success,
    TResult Function(_UnblockUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _UnblockUserStateSuccess implements UnblockUserState {
  const factory _UnblockUserStateSuccess(final bool result) =
      _$_UnblockUserStateSuccess;

  bool get result;
  @JsonKey(ignore: true)
  _$$_UnblockUserStateSuccessCopyWith<_$_UnblockUserStateSuccess>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UnblockUserStateErrorCopyWith<$Res> {
  factory _$$_UnblockUserStateErrorCopyWith(_$_UnblockUserStateError value,
          $Res Function(_$_UnblockUserStateError) then) =
      __$$_UnblockUserStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$_UnblockUserStateErrorCopyWithImpl<$Res>
    extends _$UnblockUserStateCopyWithImpl<$Res, _$_UnblockUserStateError>
    implements _$$_UnblockUserStateErrorCopyWith<$Res> {
  __$$_UnblockUserStateErrorCopyWithImpl(_$_UnblockUserStateError _value,
      $Res Function(_$_UnblockUserStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_UnblockUserStateError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$_UnblockUserStateError implements _UnblockUserStateError {
  const _$_UnblockUserStateError(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'UnblockUserState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnblockUserStateError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UnblockUserStateErrorCopyWith<_$_UnblockUserStateError> get copyWith =>
      __$$_UnblockUserStateErrorCopyWithImpl<_$_UnblockUserStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnblockUserStateInitial value) initial,
    required TResult Function(_UnblockUserStateLoading value) loading,
    required TResult Function(_UnblockUserStateSuccess value) success,
    required TResult Function(_UnblockUserStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnblockUserStateInitial value)? initial,
    TResult? Function(_UnblockUserStateLoading value)? loading,
    TResult? Function(_UnblockUserStateSuccess value)? success,
    TResult? Function(_UnblockUserStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnblockUserStateInitial value)? initial,
    TResult Function(_UnblockUserStateLoading value)? loading,
    TResult Function(_UnblockUserStateSuccess value)? success,
    TResult Function(_UnblockUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _UnblockUserStateError implements UnblockUserState {
  const factory _UnblockUserStateError(final PeamanError error) =
      _$_UnblockUserStateError;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$_UnblockUserStateErrorCopyWith<_$_UnblockUserStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UpdateUserState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateUserStateInitial value) initial,
    required TResult Function(_UpdateUserStateLoading value) loading,
    required TResult Function(_UpdateUserStateSuccess value) success,
    required TResult Function(_UpdateUserStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateUserStateInitial value)? initial,
    TResult? Function(_UpdateUserStateLoading value)? loading,
    TResult? Function(_UpdateUserStateSuccess value)? success,
    TResult? Function(_UpdateUserStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateUserStateInitial value)? initial,
    TResult Function(_UpdateUserStateLoading value)? loading,
    TResult Function(_UpdateUserStateSuccess value)? success,
    TResult Function(_UpdateUserStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateUserStateCopyWith<$Res> {
  factory $UpdateUserStateCopyWith(
          UpdateUserState value, $Res Function(UpdateUserState) then) =
      _$UpdateUserStateCopyWithImpl<$Res, UpdateUserState>;
}

/// @nodoc
class _$UpdateUserStateCopyWithImpl<$Res, $Val extends UpdateUserState>
    implements $UpdateUserStateCopyWith<$Res> {
  _$UpdateUserStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UpdateUserStateInitialCopyWith<$Res> {
  factory _$$_UpdateUserStateInitialCopyWith(_$_UpdateUserStateInitial value,
          $Res Function(_$_UpdateUserStateInitial) then) =
      __$$_UpdateUserStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UpdateUserStateInitialCopyWithImpl<$Res>
    extends _$UpdateUserStateCopyWithImpl<$Res, _$_UpdateUserStateInitial>
    implements _$$_UpdateUserStateInitialCopyWith<$Res> {
  __$$_UpdateUserStateInitialCopyWithImpl(_$_UpdateUserStateInitial _value,
      $Res Function(_$_UpdateUserStateInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UpdateUserStateInitial implements _UpdateUserStateInitial {
  const _$_UpdateUserStateInitial();

  @override
  String toString() {
    return 'UpdateUserState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateUserStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateUserStateInitial value) initial,
    required TResult Function(_UpdateUserStateLoading value) loading,
    required TResult Function(_UpdateUserStateSuccess value) success,
    required TResult Function(_UpdateUserStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateUserStateInitial value)? initial,
    TResult? Function(_UpdateUserStateLoading value)? loading,
    TResult? Function(_UpdateUserStateSuccess value)? success,
    TResult? Function(_UpdateUserStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateUserStateInitial value)? initial,
    TResult Function(_UpdateUserStateLoading value)? loading,
    TResult Function(_UpdateUserStateSuccess value)? success,
    TResult Function(_UpdateUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _UpdateUserStateInitial implements UpdateUserState {
  const factory _UpdateUserStateInitial() = _$_UpdateUserStateInitial;
}

/// @nodoc
abstract class _$$_UpdateUserStateLoadingCopyWith<$Res> {
  factory _$$_UpdateUserStateLoadingCopyWith(_$_UpdateUserStateLoading value,
          $Res Function(_$_UpdateUserStateLoading) then) =
      __$$_UpdateUserStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UpdateUserStateLoadingCopyWithImpl<$Res>
    extends _$UpdateUserStateCopyWithImpl<$Res, _$_UpdateUserStateLoading>
    implements _$$_UpdateUserStateLoadingCopyWith<$Res> {
  __$$_UpdateUserStateLoadingCopyWithImpl(_$_UpdateUserStateLoading _value,
      $Res Function(_$_UpdateUserStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UpdateUserStateLoading implements _UpdateUserStateLoading {
  const _$_UpdateUserStateLoading();

  @override
  String toString() {
    return 'UpdateUserState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateUserStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateUserStateInitial value) initial,
    required TResult Function(_UpdateUserStateLoading value) loading,
    required TResult Function(_UpdateUserStateSuccess value) success,
    required TResult Function(_UpdateUserStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateUserStateInitial value)? initial,
    TResult? Function(_UpdateUserStateLoading value)? loading,
    TResult? Function(_UpdateUserStateSuccess value)? success,
    TResult? Function(_UpdateUserStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateUserStateInitial value)? initial,
    TResult Function(_UpdateUserStateLoading value)? loading,
    TResult Function(_UpdateUserStateSuccess value)? success,
    TResult Function(_UpdateUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _UpdateUserStateLoading implements UpdateUserState {
  const factory _UpdateUserStateLoading() = _$_UpdateUserStateLoading;
}

/// @nodoc
abstract class _$$_UpdateUserStateSuccessCopyWith<$Res> {
  factory _$$_UpdateUserStateSuccessCopyWith(_$_UpdateUserStateSuccess value,
          $Res Function(_$_UpdateUserStateSuccess) then) =
      __$$_UpdateUserStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({bool result});
}

/// @nodoc
class __$$_UpdateUserStateSuccessCopyWithImpl<$Res>
    extends _$UpdateUserStateCopyWithImpl<$Res, _$_UpdateUserStateSuccess>
    implements _$$_UpdateUserStateSuccessCopyWith<$Res> {
  __$$_UpdateUserStateSuccessCopyWithImpl(_$_UpdateUserStateSuccess _value,
      $Res Function(_$_UpdateUserStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$_UpdateUserStateSuccess(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_UpdateUserStateSuccess implements _UpdateUserStateSuccess {
  const _$_UpdateUserStateSuccess(this.result);

  @override
  final bool result;

  @override
  String toString() {
    return 'UpdateUserState.success(result: $result)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateUserStateSuccess &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateUserStateSuccessCopyWith<_$_UpdateUserStateSuccess> get copyWith =>
      __$$_UpdateUserStateSuccessCopyWithImpl<_$_UpdateUserStateSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateUserStateInitial value) initial,
    required TResult Function(_UpdateUserStateLoading value) loading,
    required TResult Function(_UpdateUserStateSuccess value) success,
    required TResult Function(_UpdateUserStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateUserStateInitial value)? initial,
    TResult? Function(_UpdateUserStateLoading value)? loading,
    TResult? Function(_UpdateUserStateSuccess value)? success,
    TResult? Function(_UpdateUserStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateUserStateInitial value)? initial,
    TResult Function(_UpdateUserStateLoading value)? loading,
    TResult Function(_UpdateUserStateSuccess value)? success,
    TResult Function(_UpdateUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _UpdateUserStateSuccess implements UpdateUserState {
  const factory _UpdateUserStateSuccess(final bool result) =
      _$_UpdateUserStateSuccess;

  bool get result;
  @JsonKey(ignore: true)
  _$$_UpdateUserStateSuccessCopyWith<_$_UpdateUserStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateUserStateErrorCopyWith<$Res> {
  factory _$$_UpdateUserStateErrorCopyWith(_$_UpdateUserStateError value,
          $Res Function(_$_UpdateUserStateError) then) =
      __$$_UpdateUserStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$_UpdateUserStateErrorCopyWithImpl<$Res>
    extends _$UpdateUserStateCopyWithImpl<$Res, _$_UpdateUserStateError>
    implements _$$_UpdateUserStateErrorCopyWith<$Res> {
  __$$_UpdateUserStateErrorCopyWithImpl(_$_UpdateUserStateError _value,
      $Res Function(_$_UpdateUserStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_UpdateUserStateError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$_UpdateUserStateError implements _UpdateUserStateError {
  const _$_UpdateUserStateError(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'UpdateUserState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateUserStateError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateUserStateErrorCopyWith<_$_UpdateUserStateError> get copyWith =>
      __$$_UpdateUserStateErrorCopyWithImpl<_$_UpdateUserStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateUserStateInitial value) initial,
    required TResult Function(_UpdateUserStateLoading value) loading,
    required TResult Function(_UpdateUserStateSuccess value) success,
    required TResult Function(_UpdateUserStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateUserStateInitial value)? initial,
    TResult? Function(_UpdateUserStateLoading value)? loading,
    TResult? Function(_UpdateUserStateSuccess value)? success,
    TResult? Function(_UpdateUserStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateUserStateInitial value)? initial,
    TResult Function(_UpdateUserStateLoading value)? loading,
    TResult Function(_UpdateUserStateSuccess value)? success,
    TResult Function(_UpdateUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _UpdateUserStateError implements UpdateUserState {
  const factory _UpdateUserStateError(final PeamanError error) =
      _$_UpdateUserStateError;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$_UpdateUserStateErrorCopyWith<_$_UpdateUserStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FollowUserState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowUserStateInitial value) initial,
    required TResult Function(_FollowUserStateLoading value) loading,
    required TResult Function(_FollowUserStateSuccess value) success,
    required TResult Function(_FollowUserStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowUserStateInitial value)? initial,
    TResult? Function(_FollowUserStateLoading value)? loading,
    TResult? Function(_FollowUserStateSuccess value)? success,
    TResult? Function(_FollowUserStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowUserStateInitial value)? initial,
    TResult Function(_FollowUserStateLoading value)? loading,
    TResult Function(_FollowUserStateSuccess value)? success,
    TResult Function(_FollowUserStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FollowUserStateCopyWith<$Res> {
  factory $FollowUserStateCopyWith(
          FollowUserState value, $Res Function(FollowUserState) then) =
      _$FollowUserStateCopyWithImpl<$Res, FollowUserState>;
}

/// @nodoc
class _$FollowUserStateCopyWithImpl<$Res, $Val extends FollowUserState>
    implements $FollowUserStateCopyWith<$Res> {
  _$FollowUserStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_FollowUserStateInitialCopyWith<$Res> {
  factory _$$_FollowUserStateInitialCopyWith(_$_FollowUserStateInitial value,
          $Res Function(_$_FollowUserStateInitial) then) =
      __$$_FollowUserStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FollowUserStateInitialCopyWithImpl<$Res>
    extends _$FollowUserStateCopyWithImpl<$Res, _$_FollowUserStateInitial>
    implements _$$_FollowUserStateInitialCopyWith<$Res> {
  __$$_FollowUserStateInitialCopyWithImpl(_$_FollowUserStateInitial _value,
      $Res Function(_$_FollowUserStateInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_FollowUserStateInitial implements _FollowUserStateInitial {
  const _$_FollowUserStateInitial();

  @override
  String toString() {
    return 'FollowUserState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FollowUserStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowUserStateInitial value) initial,
    required TResult Function(_FollowUserStateLoading value) loading,
    required TResult Function(_FollowUserStateSuccess value) success,
    required TResult Function(_FollowUserStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowUserStateInitial value)? initial,
    TResult? Function(_FollowUserStateLoading value)? loading,
    TResult? Function(_FollowUserStateSuccess value)? success,
    TResult? Function(_FollowUserStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowUserStateInitial value)? initial,
    TResult Function(_FollowUserStateLoading value)? loading,
    TResult Function(_FollowUserStateSuccess value)? success,
    TResult Function(_FollowUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _FollowUserStateInitial implements FollowUserState {
  const factory _FollowUserStateInitial() = _$_FollowUserStateInitial;
}

/// @nodoc
abstract class _$$_FollowUserStateLoadingCopyWith<$Res> {
  factory _$$_FollowUserStateLoadingCopyWith(_$_FollowUserStateLoading value,
          $Res Function(_$_FollowUserStateLoading) then) =
      __$$_FollowUserStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FollowUserStateLoadingCopyWithImpl<$Res>
    extends _$FollowUserStateCopyWithImpl<$Res, _$_FollowUserStateLoading>
    implements _$$_FollowUserStateLoadingCopyWith<$Res> {
  __$$_FollowUserStateLoadingCopyWithImpl(_$_FollowUserStateLoading _value,
      $Res Function(_$_FollowUserStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_FollowUserStateLoading implements _FollowUserStateLoading {
  const _$_FollowUserStateLoading();

  @override
  String toString() {
    return 'FollowUserState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FollowUserStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowUserStateInitial value) initial,
    required TResult Function(_FollowUserStateLoading value) loading,
    required TResult Function(_FollowUserStateSuccess value) success,
    required TResult Function(_FollowUserStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowUserStateInitial value)? initial,
    TResult? Function(_FollowUserStateLoading value)? loading,
    TResult? Function(_FollowUserStateSuccess value)? success,
    TResult? Function(_FollowUserStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowUserStateInitial value)? initial,
    TResult Function(_FollowUserStateLoading value)? loading,
    TResult Function(_FollowUserStateSuccess value)? success,
    TResult Function(_FollowUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _FollowUserStateLoading implements FollowUserState {
  const factory _FollowUserStateLoading() = _$_FollowUserStateLoading;
}

/// @nodoc
abstract class _$$_FollowUserStateSuccessCopyWith<$Res> {
  factory _$$_FollowUserStateSuccessCopyWith(_$_FollowUserStateSuccess value,
          $Res Function(_$_FollowUserStateSuccess) then) =
      __$$_FollowUserStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({bool result});
}

/// @nodoc
class __$$_FollowUserStateSuccessCopyWithImpl<$Res>
    extends _$FollowUserStateCopyWithImpl<$Res, _$_FollowUserStateSuccess>
    implements _$$_FollowUserStateSuccessCopyWith<$Res> {
  __$$_FollowUserStateSuccessCopyWithImpl(_$_FollowUserStateSuccess _value,
      $Res Function(_$_FollowUserStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$_FollowUserStateSuccess(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_FollowUserStateSuccess implements _FollowUserStateSuccess {
  const _$_FollowUserStateSuccess(this.result);

  @override
  final bool result;

  @override
  String toString() {
    return 'FollowUserState.success(result: $result)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FollowUserStateSuccess &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FollowUserStateSuccessCopyWith<_$_FollowUserStateSuccess> get copyWith =>
      __$$_FollowUserStateSuccessCopyWithImpl<_$_FollowUserStateSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowUserStateInitial value) initial,
    required TResult Function(_FollowUserStateLoading value) loading,
    required TResult Function(_FollowUserStateSuccess value) success,
    required TResult Function(_FollowUserStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowUserStateInitial value)? initial,
    TResult? Function(_FollowUserStateLoading value)? loading,
    TResult? Function(_FollowUserStateSuccess value)? success,
    TResult? Function(_FollowUserStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowUserStateInitial value)? initial,
    TResult Function(_FollowUserStateLoading value)? loading,
    TResult Function(_FollowUserStateSuccess value)? success,
    TResult Function(_FollowUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _FollowUserStateSuccess implements FollowUserState {
  const factory _FollowUserStateSuccess(final bool result) =
      _$_FollowUserStateSuccess;

  bool get result;
  @JsonKey(ignore: true)
  _$$_FollowUserStateSuccessCopyWith<_$_FollowUserStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_FollowUserStateErrorCopyWith<$Res> {
  factory _$$_FollowUserStateErrorCopyWith(_$_FollowUserStateError value,
          $Res Function(_$_FollowUserStateError) then) =
      __$$_FollowUserStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$_FollowUserStateErrorCopyWithImpl<$Res>
    extends _$FollowUserStateCopyWithImpl<$Res, _$_FollowUserStateError>
    implements _$$_FollowUserStateErrorCopyWith<$Res> {
  __$$_FollowUserStateErrorCopyWithImpl(_$_FollowUserStateError _value,
      $Res Function(_$_FollowUserStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_FollowUserStateError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$_FollowUserStateError implements _FollowUserStateError {
  const _$_FollowUserStateError(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'FollowUserState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FollowUserStateError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FollowUserStateErrorCopyWith<_$_FollowUserStateError> get copyWith =>
      __$$_FollowUserStateErrorCopyWithImpl<_$_FollowUserStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowUserStateInitial value) initial,
    required TResult Function(_FollowUserStateLoading value) loading,
    required TResult Function(_FollowUserStateSuccess value) success,
    required TResult Function(_FollowUserStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowUserStateInitial value)? initial,
    TResult? Function(_FollowUserStateLoading value)? loading,
    TResult? Function(_FollowUserStateSuccess value)? success,
    TResult? Function(_FollowUserStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowUserStateInitial value)? initial,
    TResult Function(_FollowUserStateLoading value)? loading,
    TResult Function(_FollowUserStateSuccess value)? success,
    TResult Function(_FollowUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _FollowUserStateError implements FollowUserState {
  const factory _FollowUserStateError(final PeamanError error) =
      _$_FollowUserStateError;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$_FollowUserStateErrorCopyWith<_$_FollowUserStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UnfollowUserState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnfollowUserStateInitial value) initial,
    required TResult Function(_UnfollowUserStateLoading value) loading,
    required TResult Function(_UnfollowUserStateSuccess value) success,
    required TResult Function(_UnfollowUserStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnfollowUserStateInitial value)? initial,
    TResult? Function(_UnfollowUserStateLoading value)? loading,
    TResult? Function(_UnfollowUserStateSuccess value)? success,
    TResult? Function(_UnfollowUserStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnfollowUserStateInitial value)? initial,
    TResult Function(_UnfollowUserStateLoading value)? loading,
    TResult Function(_UnfollowUserStateSuccess value)? success,
    TResult Function(_UnfollowUserStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnfollowUserStateCopyWith<$Res> {
  factory $UnfollowUserStateCopyWith(
          UnfollowUserState value, $Res Function(UnfollowUserState) then) =
      _$UnfollowUserStateCopyWithImpl<$Res, UnfollowUserState>;
}

/// @nodoc
class _$UnfollowUserStateCopyWithImpl<$Res, $Val extends UnfollowUserState>
    implements $UnfollowUserStateCopyWith<$Res> {
  _$UnfollowUserStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UnfollowUserStateInitialCopyWith<$Res> {
  factory _$$_UnfollowUserStateInitialCopyWith(
          _$_UnfollowUserStateInitial value,
          $Res Function(_$_UnfollowUserStateInitial) then) =
      __$$_UnfollowUserStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnfollowUserStateInitialCopyWithImpl<$Res>
    extends _$UnfollowUserStateCopyWithImpl<$Res, _$_UnfollowUserStateInitial>
    implements _$$_UnfollowUserStateInitialCopyWith<$Res> {
  __$$_UnfollowUserStateInitialCopyWithImpl(_$_UnfollowUserStateInitial _value,
      $Res Function(_$_UnfollowUserStateInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnfollowUserStateInitial implements _UnfollowUserStateInitial {
  const _$_UnfollowUserStateInitial();

  @override
  String toString() {
    return 'UnfollowUserState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnfollowUserStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnfollowUserStateInitial value) initial,
    required TResult Function(_UnfollowUserStateLoading value) loading,
    required TResult Function(_UnfollowUserStateSuccess value) success,
    required TResult Function(_UnfollowUserStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnfollowUserStateInitial value)? initial,
    TResult? Function(_UnfollowUserStateLoading value)? loading,
    TResult? Function(_UnfollowUserStateSuccess value)? success,
    TResult? Function(_UnfollowUserStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnfollowUserStateInitial value)? initial,
    TResult Function(_UnfollowUserStateLoading value)? loading,
    TResult Function(_UnfollowUserStateSuccess value)? success,
    TResult Function(_UnfollowUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _UnfollowUserStateInitial implements UnfollowUserState {
  const factory _UnfollowUserStateInitial() = _$_UnfollowUserStateInitial;
}

/// @nodoc
abstract class _$$_UnfollowUserStateLoadingCopyWith<$Res> {
  factory _$$_UnfollowUserStateLoadingCopyWith(
          _$_UnfollowUserStateLoading value,
          $Res Function(_$_UnfollowUserStateLoading) then) =
      __$$_UnfollowUserStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnfollowUserStateLoadingCopyWithImpl<$Res>
    extends _$UnfollowUserStateCopyWithImpl<$Res, _$_UnfollowUserStateLoading>
    implements _$$_UnfollowUserStateLoadingCopyWith<$Res> {
  __$$_UnfollowUserStateLoadingCopyWithImpl(_$_UnfollowUserStateLoading _value,
      $Res Function(_$_UnfollowUserStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnfollowUserStateLoading implements _UnfollowUserStateLoading {
  const _$_UnfollowUserStateLoading();

  @override
  String toString() {
    return 'UnfollowUserState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnfollowUserStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnfollowUserStateInitial value) initial,
    required TResult Function(_UnfollowUserStateLoading value) loading,
    required TResult Function(_UnfollowUserStateSuccess value) success,
    required TResult Function(_UnfollowUserStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnfollowUserStateInitial value)? initial,
    TResult? Function(_UnfollowUserStateLoading value)? loading,
    TResult? Function(_UnfollowUserStateSuccess value)? success,
    TResult? Function(_UnfollowUserStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnfollowUserStateInitial value)? initial,
    TResult Function(_UnfollowUserStateLoading value)? loading,
    TResult Function(_UnfollowUserStateSuccess value)? success,
    TResult Function(_UnfollowUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _UnfollowUserStateLoading implements UnfollowUserState {
  const factory _UnfollowUserStateLoading() = _$_UnfollowUserStateLoading;
}

/// @nodoc
abstract class _$$_UnfollowUserStateSuccessCopyWith<$Res> {
  factory _$$_UnfollowUserStateSuccessCopyWith(
          _$_UnfollowUserStateSuccess value,
          $Res Function(_$_UnfollowUserStateSuccess) then) =
      __$$_UnfollowUserStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({bool result});
}

/// @nodoc
class __$$_UnfollowUserStateSuccessCopyWithImpl<$Res>
    extends _$UnfollowUserStateCopyWithImpl<$Res, _$_UnfollowUserStateSuccess>
    implements _$$_UnfollowUserStateSuccessCopyWith<$Res> {
  __$$_UnfollowUserStateSuccessCopyWithImpl(_$_UnfollowUserStateSuccess _value,
      $Res Function(_$_UnfollowUserStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$_UnfollowUserStateSuccess(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_UnfollowUserStateSuccess implements _UnfollowUserStateSuccess {
  const _$_UnfollowUserStateSuccess(this.result);

  @override
  final bool result;

  @override
  String toString() {
    return 'UnfollowUserState.success(result: $result)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnfollowUserStateSuccess &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UnfollowUserStateSuccessCopyWith<_$_UnfollowUserStateSuccess>
      get copyWith => __$$_UnfollowUserStateSuccessCopyWithImpl<
          _$_UnfollowUserStateSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnfollowUserStateInitial value) initial,
    required TResult Function(_UnfollowUserStateLoading value) loading,
    required TResult Function(_UnfollowUserStateSuccess value) success,
    required TResult Function(_UnfollowUserStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnfollowUserStateInitial value)? initial,
    TResult? Function(_UnfollowUserStateLoading value)? loading,
    TResult? Function(_UnfollowUserStateSuccess value)? success,
    TResult? Function(_UnfollowUserStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnfollowUserStateInitial value)? initial,
    TResult Function(_UnfollowUserStateLoading value)? loading,
    TResult Function(_UnfollowUserStateSuccess value)? success,
    TResult Function(_UnfollowUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _UnfollowUserStateSuccess implements UnfollowUserState {
  const factory _UnfollowUserStateSuccess(final bool result) =
      _$_UnfollowUserStateSuccess;

  bool get result;
  @JsonKey(ignore: true)
  _$$_UnfollowUserStateSuccessCopyWith<_$_UnfollowUserStateSuccess>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UnfollowUserStateErrorCopyWith<$Res> {
  factory _$$_UnfollowUserStateErrorCopyWith(_$_UnfollowUserStateError value,
          $Res Function(_$_UnfollowUserStateError) then) =
      __$$_UnfollowUserStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$_UnfollowUserStateErrorCopyWithImpl<$Res>
    extends _$UnfollowUserStateCopyWithImpl<$Res, _$_UnfollowUserStateError>
    implements _$$_UnfollowUserStateErrorCopyWith<$Res> {
  __$$_UnfollowUserStateErrorCopyWithImpl(_$_UnfollowUserStateError _value,
      $Res Function(_$_UnfollowUserStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_UnfollowUserStateError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$_UnfollowUserStateError implements _UnfollowUserStateError {
  const _$_UnfollowUserStateError(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'UnfollowUserState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnfollowUserStateError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UnfollowUserStateErrorCopyWith<_$_UnfollowUserStateError> get copyWith =>
      __$$_UnfollowUserStateErrorCopyWithImpl<_$_UnfollowUserStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnfollowUserStateInitial value) initial,
    required TResult Function(_UnfollowUserStateLoading value) loading,
    required TResult Function(_UnfollowUserStateSuccess value) success,
    required TResult Function(_UnfollowUserStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnfollowUserStateInitial value)? initial,
    TResult? Function(_UnfollowUserStateLoading value)? loading,
    TResult? Function(_UnfollowUserStateSuccess value)? success,
    TResult? Function(_UnfollowUserStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnfollowUserStateInitial value)? initial,
    TResult Function(_UnfollowUserStateLoading value)? loading,
    TResult Function(_UnfollowUserStateSuccess value)? success,
    TResult Function(_UnfollowUserStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _UnfollowUserStateError implements UnfollowUserState {
  const factory _UnfollowUserStateError(final PeamanError error) =
      _$_UnfollowUserStateError;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$_UnfollowUserStateErrorCopyWith<_$_UnfollowUserStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CancelFollowState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelFollowStateInitial value) initial,
    required TResult Function(_CancelFollowStateLoading value) loading,
    required TResult Function(_CancelFollowStateSuccess value) success,
    required TResult Function(_CancelFollowStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelFollowStateInitial value)? initial,
    TResult? Function(_CancelFollowStateLoading value)? loading,
    TResult? Function(_CancelFollowStateSuccess value)? success,
    TResult? Function(_CancelFollowStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelFollowStateInitial value)? initial,
    TResult Function(_CancelFollowStateLoading value)? loading,
    TResult Function(_CancelFollowStateSuccess value)? success,
    TResult Function(_CancelFollowStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CancelFollowStateCopyWith<$Res> {
  factory $CancelFollowStateCopyWith(
          CancelFollowState value, $Res Function(CancelFollowState) then) =
      _$CancelFollowStateCopyWithImpl<$Res, CancelFollowState>;
}

/// @nodoc
class _$CancelFollowStateCopyWithImpl<$Res, $Val extends CancelFollowState>
    implements $CancelFollowStateCopyWith<$Res> {
  _$CancelFollowStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_CancelFollowStateInitialCopyWith<$Res> {
  factory _$$_CancelFollowStateInitialCopyWith(
          _$_CancelFollowStateInitial value,
          $Res Function(_$_CancelFollowStateInitial) then) =
      __$$_CancelFollowStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CancelFollowStateInitialCopyWithImpl<$Res>
    extends _$CancelFollowStateCopyWithImpl<$Res, _$_CancelFollowStateInitial>
    implements _$$_CancelFollowStateInitialCopyWith<$Res> {
  __$$_CancelFollowStateInitialCopyWithImpl(_$_CancelFollowStateInitial _value,
      $Res Function(_$_CancelFollowStateInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_CancelFollowStateInitial implements _CancelFollowStateInitial {
  const _$_CancelFollowStateInitial();

  @override
  String toString() {
    return 'CancelFollowState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CancelFollowStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelFollowStateInitial value) initial,
    required TResult Function(_CancelFollowStateLoading value) loading,
    required TResult Function(_CancelFollowStateSuccess value) success,
    required TResult Function(_CancelFollowStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelFollowStateInitial value)? initial,
    TResult? Function(_CancelFollowStateLoading value)? loading,
    TResult? Function(_CancelFollowStateSuccess value)? success,
    TResult? Function(_CancelFollowStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelFollowStateInitial value)? initial,
    TResult Function(_CancelFollowStateLoading value)? loading,
    TResult Function(_CancelFollowStateSuccess value)? success,
    TResult Function(_CancelFollowStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _CancelFollowStateInitial implements CancelFollowState {
  const factory _CancelFollowStateInitial() = _$_CancelFollowStateInitial;
}

/// @nodoc
abstract class _$$_CancelFollowStateLoadingCopyWith<$Res> {
  factory _$$_CancelFollowStateLoadingCopyWith(
          _$_CancelFollowStateLoading value,
          $Res Function(_$_CancelFollowStateLoading) then) =
      __$$_CancelFollowStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CancelFollowStateLoadingCopyWithImpl<$Res>
    extends _$CancelFollowStateCopyWithImpl<$Res, _$_CancelFollowStateLoading>
    implements _$$_CancelFollowStateLoadingCopyWith<$Res> {
  __$$_CancelFollowStateLoadingCopyWithImpl(_$_CancelFollowStateLoading _value,
      $Res Function(_$_CancelFollowStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_CancelFollowStateLoading implements _CancelFollowStateLoading {
  const _$_CancelFollowStateLoading();

  @override
  String toString() {
    return 'CancelFollowState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CancelFollowStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelFollowStateInitial value) initial,
    required TResult Function(_CancelFollowStateLoading value) loading,
    required TResult Function(_CancelFollowStateSuccess value) success,
    required TResult Function(_CancelFollowStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelFollowStateInitial value)? initial,
    TResult? Function(_CancelFollowStateLoading value)? loading,
    TResult? Function(_CancelFollowStateSuccess value)? success,
    TResult? Function(_CancelFollowStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelFollowStateInitial value)? initial,
    TResult Function(_CancelFollowStateLoading value)? loading,
    TResult Function(_CancelFollowStateSuccess value)? success,
    TResult Function(_CancelFollowStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _CancelFollowStateLoading implements CancelFollowState {
  const factory _CancelFollowStateLoading() = _$_CancelFollowStateLoading;
}

/// @nodoc
abstract class _$$_CancelFollowStateSuccessCopyWith<$Res> {
  factory _$$_CancelFollowStateSuccessCopyWith(
          _$_CancelFollowStateSuccess value,
          $Res Function(_$_CancelFollowStateSuccess) then) =
      __$$_CancelFollowStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({bool result});
}

/// @nodoc
class __$$_CancelFollowStateSuccessCopyWithImpl<$Res>
    extends _$CancelFollowStateCopyWithImpl<$Res, _$_CancelFollowStateSuccess>
    implements _$$_CancelFollowStateSuccessCopyWith<$Res> {
  __$$_CancelFollowStateSuccessCopyWithImpl(_$_CancelFollowStateSuccess _value,
      $Res Function(_$_CancelFollowStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$_CancelFollowStateSuccess(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_CancelFollowStateSuccess implements _CancelFollowStateSuccess {
  const _$_CancelFollowStateSuccess(this.result);

  @override
  final bool result;

  @override
  String toString() {
    return 'CancelFollowState.success(result: $result)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CancelFollowStateSuccess &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CancelFollowStateSuccessCopyWith<_$_CancelFollowStateSuccess>
      get copyWith => __$$_CancelFollowStateSuccessCopyWithImpl<
          _$_CancelFollowStateSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelFollowStateInitial value) initial,
    required TResult Function(_CancelFollowStateLoading value) loading,
    required TResult Function(_CancelFollowStateSuccess value) success,
    required TResult Function(_CancelFollowStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelFollowStateInitial value)? initial,
    TResult? Function(_CancelFollowStateLoading value)? loading,
    TResult? Function(_CancelFollowStateSuccess value)? success,
    TResult? Function(_CancelFollowStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelFollowStateInitial value)? initial,
    TResult Function(_CancelFollowStateLoading value)? loading,
    TResult Function(_CancelFollowStateSuccess value)? success,
    TResult Function(_CancelFollowStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _CancelFollowStateSuccess implements CancelFollowState {
  const factory _CancelFollowStateSuccess(final bool result) =
      _$_CancelFollowStateSuccess;

  bool get result;
  @JsonKey(ignore: true)
  _$$_CancelFollowStateSuccessCopyWith<_$_CancelFollowStateSuccess>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_CancelFollowStateErrorCopyWith<$Res> {
  factory _$$_CancelFollowStateErrorCopyWith(_$_CancelFollowStateError value,
          $Res Function(_$_CancelFollowStateError) then) =
      __$$_CancelFollowStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$_CancelFollowStateErrorCopyWithImpl<$Res>
    extends _$CancelFollowStateCopyWithImpl<$Res, _$_CancelFollowStateError>
    implements _$$_CancelFollowStateErrorCopyWith<$Res> {
  __$$_CancelFollowStateErrorCopyWithImpl(_$_CancelFollowStateError _value,
      $Res Function(_$_CancelFollowStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_CancelFollowStateError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$_CancelFollowStateError implements _CancelFollowStateError {
  const _$_CancelFollowStateError(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'CancelFollowState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CancelFollowStateError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CancelFollowStateErrorCopyWith<_$_CancelFollowStateError> get copyWith =>
      __$$_CancelFollowStateErrorCopyWithImpl<_$_CancelFollowStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelFollowStateInitial value) initial,
    required TResult Function(_CancelFollowStateLoading value) loading,
    required TResult Function(_CancelFollowStateSuccess value) success,
    required TResult Function(_CancelFollowStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelFollowStateInitial value)? initial,
    TResult? Function(_CancelFollowStateLoading value)? loading,
    TResult? Function(_CancelFollowStateSuccess value)? success,
    TResult? Function(_CancelFollowStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelFollowStateInitial value)? initial,
    TResult Function(_CancelFollowStateLoading value)? loading,
    TResult Function(_CancelFollowStateSuccess value)? success,
    TResult Function(_CancelFollowStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _CancelFollowStateError implements CancelFollowState {
  const factory _CancelFollowStateError(final PeamanError error) =
      _$_CancelFollowStateError;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$_CancelFollowStateErrorCopyWith<_$_CancelFollowStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AcceptFollowState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AcceptFollowStateInitial value) initial,
    required TResult Function(_AcceptFollowStateLoading value) loading,
    required TResult Function(_AcceptFollowStateSuccess value) success,
    required TResult Function(_AcceptFollowStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AcceptFollowStateInitial value)? initial,
    TResult? Function(_AcceptFollowStateLoading value)? loading,
    TResult? Function(_AcceptFollowStateSuccess value)? success,
    TResult? Function(_AcceptFollowStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AcceptFollowStateInitial value)? initial,
    TResult Function(_AcceptFollowStateLoading value)? loading,
    TResult Function(_AcceptFollowStateSuccess value)? success,
    TResult Function(_AcceptFollowStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AcceptFollowStateCopyWith<$Res> {
  factory $AcceptFollowStateCopyWith(
          AcceptFollowState value, $Res Function(AcceptFollowState) then) =
      _$AcceptFollowStateCopyWithImpl<$Res, AcceptFollowState>;
}

/// @nodoc
class _$AcceptFollowStateCopyWithImpl<$Res, $Val extends AcceptFollowState>
    implements $AcceptFollowStateCopyWith<$Res> {
  _$AcceptFollowStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_AcceptFollowStateInitialCopyWith<$Res> {
  factory _$$_AcceptFollowStateInitialCopyWith(
          _$_AcceptFollowStateInitial value,
          $Res Function(_$_AcceptFollowStateInitial) then) =
      __$$_AcceptFollowStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AcceptFollowStateInitialCopyWithImpl<$Res>
    extends _$AcceptFollowStateCopyWithImpl<$Res, _$_AcceptFollowStateInitial>
    implements _$$_AcceptFollowStateInitialCopyWith<$Res> {
  __$$_AcceptFollowStateInitialCopyWithImpl(_$_AcceptFollowStateInitial _value,
      $Res Function(_$_AcceptFollowStateInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AcceptFollowStateInitial implements _AcceptFollowStateInitial {
  const _$_AcceptFollowStateInitial();

  @override
  String toString() {
    return 'AcceptFollowState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AcceptFollowStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AcceptFollowStateInitial value) initial,
    required TResult Function(_AcceptFollowStateLoading value) loading,
    required TResult Function(_AcceptFollowStateSuccess value) success,
    required TResult Function(_AcceptFollowStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AcceptFollowStateInitial value)? initial,
    TResult? Function(_AcceptFollowStateLoading value)? loading,
    TResult? Function(_AcceptFollowStateSuccess value)? success,
    TResult? Function(_AcceptFollowStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AcceptFollowStateInitial value)? initial,
    TResult Function(_AcceptFollowStateLoading value)? loading,
    TResult Function(_AcceptFollowStateSuccess value)? success,
    TResult Function(_AcceptFollowStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _AcceptFollowStateInitial implements AcceptFollowState {
  const factory _AcceptFollowStateInitial() = _$_AcceptFollowStateInitial;
}

/// @nodoc
abstract class _$$_AcceptFollowStateLoadingCopyWith<$Res> {
  factory _$$_AcceptFollowStateLoadingCopyWith(
          _$_AcceptFollowStateLoading value,
          $Res Function(_$_AcceptFollowStateLoading) then) =
      __$$_AcceptFollowStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AcceptFollowStateLoadingCopyWithImpl<$Res>
    extends _$AcceptFollowStateCopyWithImpl<$Res, _$_AcceptFollowStateLoading>
    implements _$$_AcceptFollowStateLoadingCopyWith<$Res> {
  __$$_AcceptFollowStateLoadingCopyWithImpl(_$_AcceptFollowStateLoading _value,
      $Res Function(_$_AcceptFollowStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AcceptFollowStateLoading implements _AcceptFollowStateLoading {
  const _$_AcceptFollowStateLoading();

  @override
  String toString() {
    return 'AcceptFollowState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AcceptFollowStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AcceptFollowStateInitial value) initial,
    required TResult Function(_AcceptFollowStateLoading value) loading,
    required TResult Function(_AcceptFollowStateSuccess value) success,
    required TResult Function(_AcceptFollowStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AcceptFollowStateInitial value)? initial,
    TResult? Function(_AcceptFollowStateLoading value)? loading,
    TResult? Function(_AcceptFollowStateSuccess value)? success,
    TResult? Function(_AcceptFollowStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AcceptFollowStateInitial value)? initial,
    TResult Function(_AcceptFollowStateLoading value)? loading,
    TResult Function(_AcceptFollowStateSuccess value)? success,
    TResult Function(_AcceptFollowStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _AcceptFollowStateLoading implements AcceptFollowState {
  const factory _AcceptFollowStateLoading() = _$_AcceptFollowStateLoading;
}

/// @nodoc
abstract class _$$_AcceptFollowStateSuccessCopyWith<$Res> {
  factory _$$_AcceptFollowStateSuccessCopyWith(
          _$_AcceptFollowStateSuccess value,
          $Res Function(_$_AcceptFollowStateSuccess) then) =
      __$$_AcceptFollowStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({bool result});
}

/// @nodoc
class __$$_AcceptFollowStateSuccessCopyWithImpl<$Res>
    extends _$AcceptFollowStateCopyWithImpl<$Res, _$_AcceptFollowStateSuccess>
    implements _$$_AcceptFollowStateSuccessCopyWith<$Res> {
  __$$_AcceptFollowStateSuccessCopyWithImpl(_$_AcceptFollowStateSuccess _value,
      $Res Function(_$_AcceptFollowStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$_AcceptFollowStateSuccess(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_AcceptFollowStateSuccess implements _AcceptFollowStateSuccess {
  const _$_AcceptFollowStateSuccess(this.result);

  @override
  final bool result;

  @override
  String toString() {
    return 'AcceptFollowState.success(result: $result)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AcceptFollowStateSuccess &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AcceptFollowStateSuccessCopyWith<_$_AcceptFollowStateSuccess>
      get copyWith => __$$_AcceptFollowStateSuccessCopyWithImpl<
          _$_AcceptFollowStateSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AcceptFollowStateInitial value) initial,
    required TResult Function(_AcceptFollowStateLoading value) loading,
    required TResult Function(_AcceptFollowStateSuccess value) success,
    required TResult Function(_AcceptFollowStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AcceptFollowStateInitial value)? initial,
    TResult? Function(_AcceptFollowStateLoading value)? loading,
    TResult? Function(_AcceptFollowStateSuccess value)? success,
    TResult? Function(_AcceptFollowStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AcceptFollowStateInitial value)? initial,
    TResult Function(_AcceptFollowStateLoading value)? loading,
    TResult Function(_AcceptFollowStateSuccess value)? success,
    TResult Function(_AcceptFollowStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _AcceptFollowStateSuccess implements AcceptFollowState {
  const factory _AcceptFollowStateSuccess(final bool result) =
      _$_AcceptFollowStateSuccess;

  bool get result;
  @JsonKey(ignore: true)
  _$$_AcceptFollowStateSuccessCopyWith<_$_AcceptFollowStateSuccess>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_AcceptFollowStateErrorCopyWith<$Res> {
  factory _$$_AcceptFollowStateErrorCopyWith(_$_AcceptFollowStateError value,
          $Res Function(_$_AcceptFollowStateError) then) =
      __$$_AcceptFollowStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$_AcceptFollowStateErrorCopyWithImpl<$Res>
    extends _$AcceptFollowStateCopyWithImpl<$Res, _$_AcceptFollowStateError>
    implements _$$_AcceptFollowStateErrorCopyWith<$Res> {
  __$$_AcceptFollowStateErrorCopyWithImpl(_$_AcceptFollowStateError _value,
      $Res Function(_$_AcceptFollowStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_AcceptFollowStateError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$_AcceptFollowStateError implements _AcceptFollowStateError {
  const _$_AcceptFollowStateError(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'AcceptFollowState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AcceptFollowStateError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AcceptFollowStateErrorCopyWith<_$_AcceptFollowStateError> get copyWith =>
      __$$_AcceptFollowStateErrorCopyWithImpl<_$_AcceptFollowStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AcceptFollowStateInitial value) initial,
    required TResult Function(_AcceptFollowStateLoading value) loading,
    required TResult Function(_AcceptFollowStateSuccess value) success,
    required TResult Function(_AcceptFollowStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AcceptFollowStateInitial value)? initial,
    TResult? Function(_AcceptFollowStateLoading value)? loading,
    TResult? Function(_AcceptFollowStateSuccess value)? success,
    TResult? Function(_AcceptFollowStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AcceptFollowStateInitial value)? initial,
    TResult Function(_AcceptFollowStateLoading value)? loading,
    TResult Function(_AcceptFollowStateSuccess value)? success,
    TResult Function(_AcceptFollowStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _AcceptFollowStateError implements AcceptFollowState {
  const factory _AcceptFollowStateError(final PeamanError error) =
      _$_AcceptFollowStateError;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$_AcceptFollowStateErrorCopyWith<_$_AcceptFollowStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FollowBackState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowBackStateInitial value) initial,
    required TResult Function(_FollowBackStateLoading value) loading,
    required TResult Function(_FollowBackStateSuccess value) success,
    required TResult Function(_FollowBackStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowBackStateInitial value)? initial,
    TResult? Function(_FollowBackStateLoading value)? loading,
    TResult? Function(_FollowBackStateSuccess value)? success,
    TResult? Function(_FollowBackStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowBackStateInitial value)? initial,
    TResult Function(_FollowBackStateLoading value)? loading,
    TResult Function(_FollowBackStateSuccess value)? success,
    TResult Function(_FollowBackStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FollowBackStateCopyWith<$Res> {
  factory $FollowBackStateCopyWith(
          FollowBackState value, $Res Function(FollowBackState) then) =
      _$FollowBackStateCopyWithImpl<$Res, FollowBackState>;
}

/// @nodoc
class _$FollowBackStateCopyWithImpl<$Res, $Val extends FollowBackState>
    implements $FollowBackStateCopyWith<$Res> {
  _$FollowBackStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_FollowBackStateInitialCopyWith<$Res> {
  factory _$$_FollowBackStateInitialCopyWith(_$_FollowBackStateInitial value,
          $Res Function(_$_FollowBackStateInitial) then) =
      __$$_FollowBackStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FollowBackStateInitialCopyWithImpl<$Res>
    extends _$FollowBackStateCopyWithImpl<$Res, _$_FollowBackStateInitial>
    implements _$$_FollowBackStateInitialCopyWith<$Res> {
  __$$_FollowBackStateInitialCopyWithImpl(_$_FollowBackStateInitial _value,
      $Res Function(_$_FollowBackStateInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_FollowBackStateInitial implements _FollowBackStateInitial {
  const _$_FollowBackStateInitial();

  @override
  String toString() {
    return 'FollowBackState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FollowBackStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowBackStateInitial value) initial,
    required TResult Function(_FollowBackStateLoading value) loading,
    required TResult Function(_FollowBackStateSuccess value) success,
    required TResult Function(_FollowBackStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowBackStateInitial value)? initial,
    TResult? Function(_FollowBackStateLoading value)? loading,
    TResult? Function(_FollowBackStateSuccess value)? success,
    TResult? Function(_FollowBackStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowBackStateInitial value)? initial,
    TResult Function(_FollowBackStateLoading value)? loading,
    TResult Function(_FollowBackStateSuccess value)? success,
    TResult Function(_FollowBackStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _FollowBackStateInitial implements FollowBackState {
  const factory _FollowBackStateInitial() = _$_FollowBackStateInitial;
}

/// @nodoc
abstract class _$$_FollowBackStateLoadingCopyWith<$Res> {
  factory _$$_FollowBackStateLoadingCopyWith(_$_FollowBackStateLoading value,
          $Res Function(_$_FollowBackStateLoading) then) =
      __$$_FollowBackStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FollowBackStateLoadingCopyWithImpl<$Res>
    extends _$FollowBackStateCopyWithImpl<$Res, _$_FollowBackStateLoading>
    implements _$$_FollowBackStateLoadingCopyWith<$Res> {
  __$$_FollowBackStateLoadingCopyWithImpl(_$_FollowBackStateLoading _value,
      $Res Function(_$_FollowBackStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_FollowBackStateLoading implements _FollowBackStateLoading {
  const _$_FollowBackStateLoading();

  @override
  String toString() {
    return 'FollowBackState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FollowBackStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowBackStateInitial value) initial,
    required TResult Function(_FollowBackStateLoading value) loading,
    required TResult Function(_FollowBackStateSuccess value) success,
    required TResult Function(_FollowBackStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowBackStateInitial value)? initial,
    TResult? Function(_FollowBackStateLoading value)? loading,
    TResult? Function(_FollowBackStateSuccess value)? success,
    TResult? Function(_FollowBackStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowBackStateInitial value)? initial,
    TResult Function(_FollowBackStateLoading value)? loading,
    TResult Function(_FollowBackStateSuccess value)? success,
    TResult Function(_FollowBackStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _FollowBackStateLoading implements FollowBackState {
  const factory _FollowBackStateLoading() = _$_FollowBackStateLoading;
}

/// @nodoc
abstract class _$$_FollowBackStateSuccessCopyWith<$Res> {
  factory _$$_FollowBackStateSuccessCopyWith(_$_FollowBackStateSuccess value,
          $Res Function(_$_FollowBackStateSuccess) then) =
      __$$_FollowBackStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({bool result});
}

/// @nodoc
class __$$_FollowBackStateSuccessCopyWithImpl<$Res>
    extends _$FollowBackStateCopyWithImpl<$Res, _$_FollowBackStateSuccess>
    implements _$$_FollowBackStateSuccessCopyWith<$Res> {
  __$$_FollowBackStateSuccessCopyWithImpl(_$_FollowBackStateSuccess _value,
      $Res Function(_$_FollowBackStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$_FollowBackStateSuccess(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_FollowBackStateSuccess implements _FollowBackStateSuccess {
  const _$_FollowBackStateSuccess(this.result);

  @override
  final bool result;

  @override
  String toString() {
    return 'FollowBackState.success(result: $result)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FollowBackStateSuccess &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FollowBackStateSuccessCopyWith<_$_FollowBackStateSuccess> get copyWith =>
      __$$_FollowBackStateSuccessCopyWithImpl<_$_FollowBackStateSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowBackStateInitial value) initial,
    required TResult Function(_FollowBackStateLoading value) loading,
    required TResult Function(_FollowBackStateSuccess value) success,
    required TResult Function(_FollowBackStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowBackStateInitial value)? initial,
    TResult? Function(_FollowBackStateLoading value)? loading,
    TResult? Function(_FollowBackStateSuccess value)? success,
    TResult? Function(_FollowBackStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowBackStateInitial value)? initial,
    TResult Function(_FollowBackStateLoading value)? loading,
    TResult Function(_FollowBackStateSuccess value)? success,
    TResult Function(_FollowBackStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _FollowBackStateSuccess implements FollowBackState {
  const factory _FollowBackStateSuccess(final bool result) =
      _$_FollowBackStateSuccess;

  bool get result;
  @JsonKey(ignore: true)
  _$$_FollowBackStateSuccessCopyWith<_$_FollowBackStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_FollowBackStateErrorCopyWith<$Res> {
  factory _$$_FollowBackStateErrorCopyWith(_$_FollowBackStateError value,
          $Res Function(_$_FollowBackStateError) then) =
      __$$_FollowBackStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$_FollowBackStateErrorCopyWithImpl<$Res>
    extends _$FollowBackStateCopyWithImpl<$Res, _$_FollowBackStateError>
    implements _$$_FollowBackStateErrorCopyWith<$Res> {
  __$$_FollowBackStateErrorCopyWithImpl(_$_FollowBackStateError _value,
      $Res Function(_$_FollowBackStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_FollowBackStateError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$_FollowBackStateError implements _FollowBackStateError {
  const _$_FollowBackStateError(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'FollowBackState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FollowBackStateError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FollowBackStateErrorCopyWith<_$_FollowBackStateError> get copyWith =>
      __$$_FollowBackStateErrorCopyWithImpl<_$_FollowBackStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FollowBackStateInitial value) initial,
    required TResult Function(_FollowBackStateLoading value) loading,
    required TResult Function(_FollowBackStateSuccess value) success,
    required TResult Function(_FollowBackStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FollowBackStateInitial value)? initial,
    TResult? Function(_FollowBackStateLoading value)? loading,
    TResult? Function(_FollowBackStateSuccess value)? success,
    TResult? Function(_FollowBackStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FollowBackStateInitial value)? initial,
    TResult Function(_FollowBackStateLoading value)? loading,
    TResult Function(_FollowBackStateSuccess value)? success,
    TResult Function(_FollowBackStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _FollowBackStateError implements FollowBackState {
  const factory _FollowBackStateError(final PeamanError error) =
      _$_FollowBackStateError;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$_FollowBackStateErrorCopyWith<_$_FollowBackStateError> get copyWith =>
      throw _privateConstructorUsedError;
}
